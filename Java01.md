# Java大厂面试题01

### 1.Java中==和equals和hashCode的区别

1. ​	==	所比较的是基本数据类型，则比较的是值；如果是引用类型的，则会比较他们在内存当中存放的地址（栈中的值）。对象存放在堆中，栈中存放对象的引用，所有==是对栈中的值进行比价，若为true代表变量的内存地址相等。
2. ​    equals是Object类中的方法，用于判断对象的内存地址引用是不是同一个地址（是不是一个对象）。若是类中覆盖了equals方法，就要依据具体代码来确定（String类当中的equals）。
3. ​    hashCode()计算出对象实例的哈希码，在对象进行散列时作为key存入。存在即合理，之所以有hashCode方法，是因为在批量处理对象时，hoshCode比equals快。在添加新元素时，先调用这个元素的hashCode方法，一下子能定位到它应该旋转的物理位置，若该位置没有元素，可直接存储；若该位置有元素，就调用它的equals 方法与新元素进行比较，若相同则不存，不相同，就放到该位置的链表末端。
4. ​    equals与hashCode方法关系：从逻辑上讲，相等对象的哈希值一定相等，同时由于不相等对象的哈希值也可能相同及哈希碰撞。所以我们可以得到一个一般规律：当对象，equals()相等时，hashCode()返回值一定相等，equals()不等时,hashCode()不一定不等。所以在重写equals方法时，有必要重写hashCode方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashCode()返回值。
5. ​    equals与==的关系：包装类比如说  Integer i = 127 在-128到127这个范围内，用的是原生的数据类型int，会在内存里重用，所有当用==去比较时，只是对原生数据类型的数值进行比较。而超出这个范围，那==比较的可就是地址了。

### 2.int、char、long各占多少个字节

- byte/boolean	**1**个字节
- short/char	     **2**个字节
- int/float              **4**个字节
- long                     **8**个字节

### 3.int与Integer的区别

- Interger是int的包装类属于引用类型，而int在Java中是基本数据类型；
- Interger需要实例化对象才可以使用，而int是直接存储数据的值；
- Interger的默认值是null，而int默认值是0

### 4.谈谈对Java多态的理解

- 同一个消息根据发送对象的不同而采取不同的行动方式，在执行过程中，通过对象的实际类型，去调用对应的方法。
- 作用：消除了类型之间的耦合关系
- 实现多态的必要条件：继承、重写（调用父类中存在的方法）、父类引用指向子类对象

### 5.String、StringBuffer、StringBuilder区别

1. 都是字符串类，String类通过字符数组保存字符串，因为有final修饰，String对象的不可变的，每次操作都会生成新的String对象，这样效率低、且浪费空间。但是线程安全。
2. StringBuffer和StringBuilder也是使用字符数组保存字符，但是这两种对象是可变的，例如：对这样的字符串进行append操作，不会产生新的对象。他们的区别是：StringBuffer对方法加了同步锁，是线程安全的，而StringBuilder是不安全的。

### 6.什么是内部类？内部类的作用

- 内部类值在类的内部再定义另一个类。
- 内部类的作用：
  - 实现多继承
  - 可以实现隐藏（内部类可以有private或者protected权限）
  - 减少了类文件编译之后的字节码文件大小

*内部类再编译完之后也会产生.class文件，但是文件的名称是：外部类名称$内部类名称.class。*

**分类：**

1. 成员内部类：作为外部类的一个成员存在，与外部类的属性、方法并列，成员内部类持有外部类的引用，成员内部类不能定义static变量和方法。
   1. 应用场景：每一个外部类需要一个内部类实例，内部类离不开外部类存在。

2. 静态内部类：内部类以static声明，其他类可通过外部类.内部类来访问。特点：不会持有外部类的引用，可以访问外部类的静态变量，若要访问成员变量需通过外部类的实例访问。
   1. 应用场景：内部类不需要外部类的实例，仅为外部类提供或逻辑上属于外部类，逻辑上可单独存在。
   2. 意义：加强了类的封装性（静态内部类的外部类的子行为或子属性，两者保持一定的关系），提高了代码的可读性（相关代码放在一起）。
3. 匿名内部类：在整个操作中只使用一次，没有名字，使用new创建，没有具体位置。
4. 局部内部类：在方法内或是代码中定义类。

### 7.抽象类和接口区别

- 抽象类在类前面需用abstract关键字修饰，一般至少包含一个抽象方法，抽象方法指只有声明，用关键字abstract修饰，没有具体的实现的方法。因抽象类中含有无具体实现，也是抽象类。抽象类也可以有成员变量和普通的成员方法。抽象方法必须为public或protected（若为private，不能被子类继承，子类无法实现该方法）。若一个类继承抽象类，则必须实现父类中的抽象方法，若子类没有实现父类的抽象方法，则也该定义为抽象类。
- 接口用关键字interface修饰，接口也可以含有变量和方法，接口中的变量会被隐式指定为public static final 变量。方法会被隐式的指定为public abstract ，接口中所有方法均不能有具体的实现，即接口中的方法必须为抽象方法。若一个非抽象类实现某个接口，必须实现该接口中的所有方法。

​	***区别***：

1. 抽象类可以提供成员方法实现的细节，而接口只能存在抽象方法；
2. 抽象类的成员变量可以是各种类型，而接口中的成员变量只能是 public static final 类型；
3. 接口中不能含有静态方法及静态代码块，而抽象类可以有静态方法和静态代码块；
4. 一个类只能继承一个抽象类，用extends来继承，却可以实现多个接口，用implements来实现接口。

##### 7.1抽象类的意义

​	抽象类是用来提供子类的通用性，用来创建继承层级里子类的模板，减少代码编写，有利于代码规范化。

##### 7.2接口的意义

1. 有利于代码的规范，对于大型项目，对一些接口进行定义，可以给开发人员一个清晰的指示，防止开发人员随意命名和代码混乱，影响开发效率。
2. 有利于代码的维护和扩展，当前类不能满足要求时，不需要重新设计类，只需要重新写类对应实现的方法。
3. 解耦作用，全局变量的定义，当需求变化时，只需改变接口中的值即可。
4. 直接看接口，就可以清楚知道具体实现类间的关系，代码交给别人看，别人也能立马明白。

